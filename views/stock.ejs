<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jusik Game</title>
    <style>
      .graph {
        position: relative;
        background-color: lightgray;
        width: min-content;
        padding: 10px;
      }

      .point {
        position: absolute;
        width: 4px;
        height: 4px;
        border-radius: 100%;
        background-color: black;
      }

      .point-price {
        position: absolute;
        background-color: black;
        color: white;
        display: none;
        pointer-events: none;
        padding: 4px;
        border-radius: 8px;
        border: 2px solid white;
        z-index: 1000;
      }

      .point-price::before {
        content: "";
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 100%;
        background-color: black;
        border: 2px solid white;
        left: -12px;
        top: -12px;
      }

    </style>
  </head>
  <body>
    <%- include("./nav.ejs") %>
    <h1><%= stock.name %></h1>
    <h2><%= stock.currentPrice %>C</h2>
    <div>
      <div class="graph">
        <canvas></canvas>
        <div class="point-price"></div>
      </div>
      <ul>
        <% for (let user of stock.users) { %>
        <li><%= user.username %> - <%= user.quantity %>주</li>
        <% } %>
      </ul>
    </div>
    <% if (loggedUser) { %>
      <button id="buy">구매</button>
      <button id="sell">판매</button>
    <% } %>

    <script src="https://kit.fontawesome.com/e217a51301.js" crossorigin="anonymous"></script>
    <script>
      const buyButton = document.getElementById("buy");
      const sellButton = document.getElementById("sell");
      const stockId = new URLSearchParams(location.search).get("stockId");

      async function buy() {
        const quantity = prompt("몆 주를 구매하시겠습니까?");
        if (isNaN(Number(quantity))) {
          alert("숫자로 입력해 주세요.");
          return;
        }

        const res = await fetch("/stock/buy", {
          method: "post",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ quantity, stockId })
        });

        if (res.status !== 200) {
          const { message } = await res.json();
          alert(message);
          return;
        }

        alert("구매하였습니다.");
        location.reload();
      }

      async function sell() {
        const quantity = prompt("몆 주를 판매하시겠습니까?");
        if (isNaN(Number(quantity))) {
          alert("숫자로 입력해 주세요.");
          return;
        }

        const res = await fetch("/stock/sell", {
          method: "post",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ quantity, stockId })
        });

        if (res.status !== 200) {
          const { message } = await res.json();
          alert(message);
          return;
        }

        alert("판매하였습니다.");
        location.reload();
      }

      buyButton?.addEventListener("click", buy);
      sellButton?.addEventListener("click", sell);

      const priceHistory = JSON.parse("[<%= stock.priceHistory %>]");
      priceHistory.push(Number("<%= stock.currentPrice %>"));
      const canvas = document.querySelector("canvas");
      const graph = document.querySelector(".graph");
      const pointPrice = document.querySelector(".point-price");
      const points = [];
      const context = canvas.getContext("2d");

      context.strokeStyle = "black";
      context.lineWidth = 2;

      for (let i = 0; i < priceHistory.length; i++) {
        const point = document.createElement("div");
        point.classList.add("point");
        point.dataset.price = priceHistory[i];
        points.push(point);
        graph.appendChild(point);
      }

      function drawGraph() {
        let min = Infinity,
          max = -Infinity;

        for (let price of priceHistory) {
          if (price < min) {
            min = price;
          }

          if (price > max) {
            max = price;
          }
        }

        min = Math.floor(min / 1000) * 1000;
        max = Math.ceil(max / 1000) * 1000;

        const a = canvas.width / (priceHistory.length - 1);
        let prevPos;

        for (let i = 0; i < priceHistory.length; i++) {
          const x = a * i;
          const y = (1 - (priceHistory[i] - min) / (max - min)) * (canvas.height - 4) + 2;

          points[i].style.left = `${x + 8}px`;
          points[i].style.top = `${y + 8}px`;

          if (i === 0) {
            prevPos = {
              x,
              y
            };
            continue;
          }

          context.beginPath();
          context.moveTo(prevPos.x, prevPos.y);
          context.lineTo(x, y);
          context.stroke();

          prevPos = {
            x,
            y
          };
        }
      }

      function showPointPrice(mouseX, mouseY) {
        const closest = {
          point: null,
          x: Infinity,
          y: Infinity
        };

        for (let point of points) {
          let x = point.style.left;
          let y = point.style.top;
          x = Number(x.substring(0, x.length - 2));
          y = Number(y.substring(0, y.length - 2));

          const dx1 = Math.abs(mouseX - closest.x);
          const dy1 = Math.abs(mouseY - closest.y);
          const d1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

          const dx2 = Math.abs(mouseX - x);
          const dy2 = Math.abs(mouseY - y);
          const d2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

          if (d2 < d1) {
            closest.point = point;
            closest.x = x;
            closest.y = y;
          }
        }

        pointPrice.style.left = closest.x + 6 + "px";
        pointPrice.style.top = closest.y + 6 + "px";
        pointPrice.innerText = closest.point.dataset.price + "C";
      }

      function resizeCanvas() {
        canvas.width = window.visualViewport.width / 3;
        canvas.height = canvas.width * (9 / 16);
      }

      let timeout;

      function debounce(f, t) {
        clearTimeout(timeout);
        timeout = setTimeout(f, t);
      }

      window.addEventListener("resize", () => debounce(() => {
        resizeCanvas();
        drawGraph();
      }, 400));

      graph.addEventListener("mouseover", () => pointPrice.style.display = "block");
      graph.addEventListener("mousemove", ({
        offsetX: x,
        offsetY: y
      }) => showPointPrice(x, y));
      graph.addEventListener("mouseleave", () => pointPrice.style.display = "none");

      resizeCanvas();
      drawGraph();
    </script>
  </body>
</html>
